#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_ARB_gpu_shader_int64 : require

// GpuOctreeNode matches Rust struct (48 bytes)
// children: [u32; 8] = 32 bytes
// flags: u32 = 4 bytes (bits 0-7: valid_mask, bits 8-15: leaf_mask)
// _padding: [u32; 3] = 12 bytes
struct GpuOctreeNode {
    uint children[8];
    uint flags;
    uint _padding[3];
};

// Buffer reference for SVO-DAG nodes
layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer NodeBuffer {
    GpuOctreeNode nodes[];
};

// Push constants (32 bytes)
layout(push_constant) uniform PushConstants {
    uvec2 screen_size;      // 8 bytes
    uint max_steps;         // 4 bytes
    uint _padding;          // 4 bytes
    uint64_t node_buffer_address;  // 8 bytes
    uint root_index;        // 4 bytes
    uint octree_depth;      // 4 bytes
} pc;

// Camera uniforms (must match CameraUniforms in Rust)
layout(set = 0, binding = 0) uniform CameraData {
    mat4 view;
    mat4 projection;
    mat4 inverse_view;
    mat4 inverse_projection;
    vec4 position;
    vec4 direction;
} camera;

// Output image
layout(set = 0, binding = 1, rgba8) writeonly uniform image2D output_image;

// Workgroup size: 8x8 threads
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ============================================================================
// Helper Functions
// ============================================================================

uint get_valid_mask(GpuOctreeNode node) {
    return node.flags & 0xFFu;
}

uint get_leaf_mask(GpuOctreeNode node) {
    return (node.flags >> 8) & 0xFFu;
}

bool has_child(GpuOctreeNode node, uint index) {
    return (get_valid_mask(node) & (1u << index)) != 0u;
}

bool is_leaf(GpuOctreeNode node, uint index) {
    return (get_leaf_mask(node) & (1u << index)) != 0u;
}

// Calculate child octant index from relative position within current node
uint get_child_index(vec3 rel_pos, float half_size) {
    uint xi = rel_pos.x >= half_size ? 1u : 0u;
    uint yi = rel_pos.y >= half_size ? 1u : 0u;
    uint zi = rel_pos.z >= half_size ? 1u : 0u;
    return xi | (yi << 1) | (zi << 2);
}

// Get child octant min offset
vec3 get_child_offset(uint child_index, float half_size) {
    return vec3(
        (child_index & 1u) != 0u ? half_size : 0.0,
        (child_index & 2u) != 0u ? half_size : 0.0,
        (child_index & 4u) != 0u ? half_size : 0.0
    );
}

// Ray-AABB intersection using slab method
// Returns true if ray intersects box, with t_near and t_far
bool ray_aabb_intersect(vec3 ray_origin, vec3 ray_dir_inv,
                        vec3 box_min, vec3 box_max,
                        out float t_near, out float t_far) {
    vec3 t1 = (box_min - ray_origin) * ray_dir_inv;
    vec3 t2 = (box_max - ray_origin) * ray_dir_inv;

    vec3 t_min_v = min(t1, t2);
    vec3 t_max_v = max(t1, t2);

    t_near = max(max(t_min_v.x, t_min_v.y), t_min_v.z);
    t_far = min(min(t_max_v.x, t_max_v.y), t_max_v.z);

    return t_near <= t_far && t_far >= 0.0;
}

// Calculate surface normal from hit point on AABB
vec3 calculate_normal(vec3 hit_point, vec3 box_min, vec3 box_max) {
    vec3 center = (box_min + box_max) * 0.5;
    vec3 half_size = (box_max - box_min) * 0.5;
    vec3 rel = hit_point - center;
    vec3 abs_rel = abs(rel) / half_size;

    // Find which face was hit (largest component)
    if (abs_rel.x > abs_rel.y && abs_rel.x > abs_rel.z) {
        return vec3(sign(rel.x), 0.0, 0.0);
    } else if (abs_rel.y > abs_rel.z) {
        return vec3(0.0, sign(rel.y), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(rel.z));
    }
}

// ============================================================================
// Ray Tracing
// ============================================================================

struct RayHit {
    bool hit;
    uint block_id;
    vec3 position;
    vec3 normal;
    float t;
};

// Stack entry for traversal
struct StackEntry {
    uint node_index;
    vec3 box_min;
    float size;
};

RayHit trace_ray(vec3 ray_origin, vec3 ray_dir) {
    RayHit result;
    result.hit = false;
    result.block_id = 0u;
    result.t = 1e30;
    result.position = vec3(0.0);
    result.normal = vec3(0.0);

    // Early exit if empty octree
    if (pc.root_index == 0u) {
        return result;
    }

    NodeBuffer nodes = NodeBuffer(pc.node_buffer_address);

    float octree_size = float(1u << pc.octree_depth);
    vec3 ray_dir_inv = 1.0 / ray_dir;

    // Check if ray intersects octree bounds
    float t_entry, t_exit;
    if (!ray_aabb_intersect(ray_origin, ray_dir_inv,
                            vec3(0.0), vec3(octree_size),
                            t_entry, t_exit)) {
        return result;
    }

    // Stack-based DFS traversal
    StackEntry stack[32];
    int stack_ptr = 0;

    // Push root
    stack[stack_ptr].node_index = pc.root_index;
    stack[stack_ptr].box_min = vec3(0.0);
    stack[stack_ptr].size = octree_size;
    stack_ptr++;

    uint steps = 0u;

    while (stack_ptr > 0 && steps < pc.max_steps) {
        steps++;

        // Pop entry
        stack_ptr--;
        StackEntry entry = stack[stack_ptr];

        GpuOctreeNode node = nodes.nodes[entry.node_index];
        float half_size = entry.size * 0.5;

        // Process all 8 children, sorted by distance (front-to-back)
        // For simplicity, we process all and rely on early exit
        for (uint i = 0u; i < 8u; i++) {
            if (!has_child(node, i)) {
                continue;
            }

            // Calculate child AABB
            vec3 child_min = entry.box_min + get_child_offset(i, half_size);
            vec3 child_max = child_min + vec3(half_size);

            // Ray-child intersection test
            float child_t_near, child_t_far;
            if (!ray_aabb_intersect(ray_origin, ray_dir_inv,
                                    child_min, child_max,
                                    child_t_near, child_t_far)) {
                continue;
            }

            // Skip if already found closer hit
            if (child_t_near > result.t) {
                continue;
            }

            if (is_leaf(node, i)) {
                // This child is a leaf - check for hit
                uint block_id = node.children[i];
                if (block_id != 0u) {
                    // Hit! Record if closer
                    float hit_t = max(child_t_near, 0.001);
                    if (hit_t < result.t) {
                        result.hit = true;
                        result.block_id = block_id;
                        result.t = hit_t;
                        result.position = ray_origin + ray_dir * hit_t;
                        result.normal = calculate_normal(result.position, child_min, child_max);
                    }
                }
            } else {
                // Branch node - push to stack for further traversal
                if (stack_ptr < 32) {
                    stack[stack_ptr].node_index = node.children[i];
                    stack[stack_ptr].box_min = child_min;
                    stack[stack_ptr].size = half_size;
                    stack_ptr++;
                }
            }
        }
    }

    return result;
}

// ============================================================================
// Shading
// ============================================================================

vec3 get_block_color(uint block_id) {
    // Block colors (matching voxelicous-core BlockId constants)
    // AIR = 0, STONE = 1, DIRT = 2, GRASS = 3
    switch (block_id) {
        case 1u: return vec3(0.5, 0.5, 0.5);         // Stone - gray
        case 2u: return vec3(0.54, 0.35, 0.17);      // Dirt - brown
        case 3u: return vec3(0.34, 0.49, 0.27);      // Grass - green
        default: return vec3(0.8, 0.2, 0.8);         // Unknown - magenta
    }
}

vec3 shade(RayHit hit, vec3 ray_dir) {
    if (!hit.hit) {
        // Sky gradient
        float t = 0.5 * (ray_dir.y + 1.0);
        return mix(vec3(0.8, 0.85, 0.9), vec3(0.4, 0.6, 0.9), t);
    }

    vec3 base_color = get_block_color(hit.block_id);

    // Simple directional light (sun)
    vec3 light_dir = normalize(vec3(0.5, 1.0, 0.3));
    float ndotl = max(dot(hit.normal, light_dir), 0.0);

    // Ambient + diffuse
    float ambient = 0.3;
    float diffuse = 0.7 * ndotl;

    return base_color * (ambient + diffuse);
}

// ============================================================================
// Main
// ============================================================================

void main() {
    uvec2 pixel = gl_GlobalInvocationID.xy;

    // Bounds check
    if (pixel.x >= pc.screen_size.x || pixel.y >= pc.screen_size.y) {
        return;
    }

    // Calculate normalized device coordinates
    vec2 uv = (vec2(pixel) + 0.5) / vec2(pc.screen_size);
    vec2 ndc = uv * 2.0 - 1.0;

    // Generate ray from camera
    // Vulkan uses Y-down, so flip Y
    vec4 clip = vec4(ndc.x, -ndc.y, 1.0, 1.0);
    vec4 view_pos = camera.inverse_projection * clip;
    view_pos = vec4(view_pos.xyz / view_pos.w, 0.0);

    vec3 ray_origin = camera.position.xyz;
    vec3 ray_dir = normalize((camera.inverse_view * view_pos).xyz);

    // Trace ray through SVO-DAG
    RayHit hit = trace_ray(ray_origin, ray_dir);

    // Apply shading
    vec3 color = shade(hit, ray_dir);

    // Write output
    imageStore(output_image, ivec2(pixel), vec4(color, 1.0));
}
