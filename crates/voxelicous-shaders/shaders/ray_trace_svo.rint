#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_ARB_gpu_shader_int64 : require

// GpuOctreeNode matches Rust struct (48 bytes)
struct GpuOctreeNode {
    uint children[8];   // 32 bytes
    uint flags;         // 4 bytes (bits 0-7: valid_mask, bits 8-15: leaf_mask)
    uint _padding[3];   // 12 bytes
};

// Buffer reference for SVO-DAG nodes
layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer NodeBuffer {
    GpuOctreeNode nodes[];
};

// Push constants (32 bytes, same as compute path)
layout(push_constant) uniform PushConstants {
    uvec2 screen_size;              // 8 bytes
    uint max_steps;                 // 4 bytes
    uint _padding;                  // 4 bytes
    uint64_t node_buffer_address;   // 8 bytes
    uint root_index;                // 4 bytes
    uint octree_depth;              // 4 bytes
} pc;

// Hit attributes passed to closest-hit shader
// xyz = surface normal, w = block_id (as float bits)
hitAttributeEXT vec4 hit_attribs;

// ============================================================================
// Helper Functions (same as compute shader)
// ============================================================================

uint get_valid_mask(GpuOctreeNode node) {
    return node.flags & 0xFFu;
}

uint get_leaf_mask(GpuOctreeNode node) {
    return (node.flags >> 8) & 0xFFu;
}

bool has_child(GpuOctreeNode node, uint index) {
    return (get_valid_mask(node) & (1u << index)) != 0u;
}

bool is_leaf(GpuOctreeNode node, uint index) {
    return (get_leaf_mask(node) & (1u << index)) != 0u;
}

vec3 get_child_offset(uint child_index, float half_size) {
    return vec3(
        (child_index & 1u) != 0u ? half_size : 0.0,
        (child_index & 2u) != 0u ? half_size : 0.0,
        (child_index & 4u) != 0u ? half_size : 0.0
    );
}

// Ray-AABB intersection using slab method
bool ray_aabb_intersect(vec3 ray_origin, vec3 ray_dir_inv,
                        vec3 box_min, vec3 box_max,
                        out float t_near, out float t_far) {
    vec3 t1 = (box_min - ray_origin) * ray_dir_inv;
    vec3 t2 = (box_max - ray_origin) * ray_dir_inv;

    vec3 t_min_v = min(t1, t2);
    vec3 t_max_v = max(t1, t2);

    t_near = max(max(t_min_v.x, t_min_v.y), t_min_v.z);
    t_far = min(min(t_max_v.x, t_max_v.y), t_max_v.z);

    return t_near <= t_far && t_far >= 0.0;
}

// Calculate surface normal from hit point on AABB
vec3 calculate_normal(vec3 hit_point, vec3 box_min, vec3 box_max) {
    vec3 center = (box_min + box_max) * 0.5;
    vec3 half_size = (box_max - box_min) * 0.5;
    vec3 rel = hit_point - center;
    vec3 abs_rel = abs(rel) / half_size;

    if (abs_rel.x > abs_rel.y && abs_rel.x > abs_rel.z) {
        return vec3(sign(rel.x), 0.0, 0.0);
    } else if (abs_rel.y > abs_rel.z) {
        return vec3(0.0, sign(rel.y), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(rel.z));
    }
}

// ============================================================================
// Stack Entry for Traversal
// ============================================================================

struct StackEntry {
    uint node_index;
    vec3 box_min;
    float size;
};

// ============================================================================
// Intersection Shader Main
// ============================================================================

void main() {
    // Early exit for empty octree
    if (pc.root_index == 0u) {
        return;  // No intersection reported
    }

    NodeBuffer nodes = NodeBuffer(pc.node_buffer_address);

    // Ray in object space (for procedural geometry, this is world space)
    vec3 ray_origin = gl_ObjectRayOriginEXT;
    vec3 ray_dir = gl_ObjectRayDirectionEXT;
    vec3 ray_dir_inv = 1.0 / ray_dir;

    float octree_size = float(1u << pc.octree_depth);
    float best_t = gl_RayTmaxEXT;
    bool found_hit = false;
    vec3 hit_normal = vec3(0.0);
    uint hit_block_id = 0u;

    // Stack-based DFS traversal
    StackEntry stack[32];
    int stack_ptr = 0;

    // Push root
    stack[stack_ptr].node_index = pc.root_index;
    stack[stack_ptr].box_min = vec3(0.0);
    stack[stack_ptr].size = octree_size;
    stack_ptr++;

    uint steps = 0u;

    while (stack_ptr > 0 && steps < pc.max_steps) {
        steps++;

        // Pop entry
        stack_ptr--;
        StackEntry entry = stack[stack_ptr];

        GpuOctreeNode node = nodes.nodes[entry.node_index];
        float half_size = entry.size * 0.5;

        // Process all 8 children
        for (uint i = 0u; i < 8u; i++) {
            if (!has_child(node, i)) {
                continue;
            }

            // Calculate child AABB
            vec3 child_min = entry.box_min + get_child_offset(i, half_size);
            vec3 child_max = child_min + vec3(half_size);

            // Ray-child intersection test
            float child_t_near, child_t_far;
            if (!ray_aabb_intersect(ray_origin, ray_dir_inv,
                                    child_min, child_max,
                                    child_t_near, child_t_far)) {
                continue;
            }

            // Skip if outside valid range
            if (child_t_near > best_t || child_t_near < gl_RayTminEXT) {
                continue;
            }

            if (is_leaf(node, i)) {
                // Leaf node - check for solid voxel
                uint block_id = node.children[i];
                if (block_id != 0u) {
                    float hit_t = max(child_t_near, gl_RayTminEXT);
                    if (hit_t < best_t) {
                        found_hit = true;
                        best_t = hit_t;
                        hit_block_id = block_id;
                        vec3 hit_pos = ray_origin + ray_dir * hit_t;
                        hit_normal = calculate_normal(hit_pos, child_min, child_max);
                    }
                }
            } else {
                // Branch node - push to stack
                if (stack_ptr < 32) {
                    stack[stack_ptr].node_index = node.children[i];
                    stack[stack_ptr].box_min = child_min;
                    stack[stack_ptr].size = half_size;
                    stack_ptr++;
                }
            }
        }
    }

    // Report intersection if found
    if (found_hit) {
        // Pack hit data into attributes
        hit_attribs = vec4(hit_normal, uintBitsToFloat(hit_block_id));
        reportIntersectionEXT(best_t, 0);
    }
}
