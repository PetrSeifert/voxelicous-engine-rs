#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_gpu_shader_int64 : require

// Output image
layout(set = 0, binding = 0, rgba8) writeonly uniform image2D output_image;

// Top-level acceleration structure
layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;

// Camera uniforms (must match CameraUniforms in Rust)
layout(set = 0, binding = 2) uniform CameraData {
    mat4 view;
    mat4 projection;
    mat4 inverse_view;
    mat4 inverse_projection;
    vec4 position;
    vec4 direction;
} camera;

// Push constants (32 bytes, same as compute path)
layout(push_constant) uniform PushConstants {
    uvec2 screen_size;              // 8 bytes
    uint max_steps;                 // 4 bytes
    uint _padding;                  // 4 bytes
    uint64_t node_buffer_address;   // 8 bytes
    uint root_index;                // 4 bytes
    uint octree_depth;              // 4 bytes
} pc;

// Ray payload - color result from hit/miss
layout(location = 0) rayPayloadEXT vec4 payload;

void main() {
    uvec2 pixel = gl_LaunchIDEXT.xy;

    // Bounds check
    if (pixel.x >= pc.screen_size.x || pixel.y >= pc.screen_size.y) {
        return;
    }

    // Calculate normalized device coordinates
    vec2 uv = (vec2(pixel) + 0.5) / vec2(pc.screen_size);
    vec2 ndc = uv * 2.0 - 1.0;

    // Generate ray from camera (Vulkan uses Y-down, so flip Y)
    vec4 clip = vec4(ndc.x, -ndc.y, 1.0, 1.0);
    vec4 view_pos = camera.inverse_projection * clip;
    view_pos = vec4(view_pos.xyz / view_pos.w, 0.0);

    vec3 ray_origin = camera.position.xyz;
    vec3 ray_dir = normalize((camera.inverse_view * view_pos).xyz);

    // Initialize payload
    payload = vec4(0.0);

    // Trace ray through acceleration structure
    float t_min = 0.001;
    float t_max = 10000.0;

    traceRayEXT(
        tlas,                       // Acceleration structure
        gl_RayFlagsOpaqueEXT,       // Ray flags (treat all geometry as opaque)
        0xFF,                       // Cull mask (hit everything)
        0,                          // SBT offset (hit group index)
        0,                          // SBT stride
        0,                          // Miss shader index
        ray_origin,                 // Ray origin
        t_min,                      // T min
        ray_dir,                    // Ray direction
        t_max,                      // T max
        0                           // Payload location
    );

    // Write result from payload
    imageStore(output_image, ivec2(pixel), payload);
}
