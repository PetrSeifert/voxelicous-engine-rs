#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_ARB_gpu_shader_int64 : require

// Constants
const uint LOD_COUNT = 6u;
const uint PAGE_GRID = 64u;
const uint PAGE_BRICKS = 64u;
const uint PAGE_BRICKS_AXIS = 4u;
const uint BRICK_SIZE = 8u;
const uint PAGE_VOXELS_AXIS = 32u;

const uint STRIDE_PALETTE16 = 288u;
const uint STRIDE_PALETTE32 = 384u;
const uint STRIDE_RAW16 = 1024u;
const float DDA_EPS = 1e-4;
const float TAU = 6.28318530718;

// Buffer references
layout(buffer_reference, scalar, buffer_reference_align = 8) readonly buffer ClipmapInfoBuffer {
    uint64_t page_brick_indices_addr[LOD_COUNT];
    uint64_t page_occ_addr[LOD_COUNT];
    uint64_t page_coord_addr[LOD_COUNT];
    uint64_t brick_header_addr;
    uint64_t palette16_addr;
    uint64_t palette32_addr;
    uint64_t raw16_addr;
    uint64_t _pad0[2];
    ivec4 origin[LOD_COUNT];
    uvec4 voxel_size[LOD_COUNT];
    vec4 lod_aabb_min[LOD_COUNT];
    vec4 lod_aabb_max[LOD_COUNT];
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer PageBrickBuffer {
    uint data[];
};

layout(buffer_reference, scalar, buffer_reference_align = 8) readonly buffer PageOccBuffer {
    uvec2 data[];
};

layout(buffer_reference, scalar, buffer_reference_align = 16) readonly buffer PageCoordBuffer {
    ivec4 data[];
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer ByteAddressBuffer {
    uint data[];
};

// Debug mode constants
const uint DEBUG_NONE = 0u;
const uint DEBUG_TRAVERSAL_STEPS = 1u;
const uint DEBUG_NODE_DEPTH = 2u;
const uint DEBUG_DISTANCE = 3u;
const uint DEBUG_NORMALS = 4u;
const uint DEBUG_BIOMES = 5u;
const uint DEBUG_CHUNK_BOUNDARIES = 6u;

// Push constants
layout(push_constant) uniform PushConstants {
    uvec2 screen_size;
    uint max_steps;
    uint _pad0;
    uint64_t clipmap_info_address;
    uint debug_mode;
    uint _pad1;
} pc;

// Camera uniforms
layout(set = 0, binding = 0) uniform CameraData {
    mat4 view;
    mat4 projection;
    mat4 inverse_view;
    mat4 inverse_projection;
    vec4 position;
    vec4 direction;
    vec4 day_night;
} camera;

// Output image
layout(set = 0, binding = 1, rgba8) writeonly uniform image2D output_image;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Helper functions
bool ray_aabb_intersect(vec3 ray_origin, vec3 ray_dir_inv,
                        vec3 box_min, vec3 box_max,
                        out float t_near, out float t_far) {
    vec3 t1 = (box_min - ray_origin) * ray_dir_inv;
    vec3 t2 = (box_max - ray_origin) * ray_dir_inv;

    vec3 t_min_v = min(t1, t2);
    vec3 t_max_v = max(t1, t2);

    t_near = max(max(t_min_v.x, t_min_v.y), t_min_v.z);
    t_far = min(min(t_max_v.x, t_max_v.y), t_max_v.z);

    return t_near <= t_far && t_far >= 0.0;
}

uint read_u8(ByteAddressBuffer buf, uint byte_idx) {
    uint word = buf.data[byte_idx >> 2];
    uint shift = (byte_idx & 3u) * 8u;
    return (word >> shift) & 0xFFu;
}

uint read_u16(ByteAddressBuffer buf, uint byte_idx) {
    uint lo = read_u8(buf, byte_idx);
    uint hi = read_u8(buf, byte_idx + 1u);
    return lo | (hi << 8u);
}

uint read_u32(ByteAddressBuffer buf, uint byte_idx) {
    uint b0 = read_u8(buf, byte_idx);
    uint b1 = read_u8(buf, byte_idx + 1u);
    uint b2 = read_u8(buf, byte_idx + 2u);
    uint b3 = read_u8(buf, byte_idx + 3u);
    return b0 | (b1 << 8u) | (b2 << 16u) | (b3 << 24u);
}

uint palette16_lookup(ByteAddressBuffer buf, uint base, uint voxel_idx) {
    uint palette_idx = voxel_idx >> 1;
    uint packed = read_u8(buf, base + 32u + palette_idx);
    uint nibble = (voxel_idx & 1u) == 0u ? (packed & 0xFu) : ((packed >> 4u) & 0xFu);
    return read_u16(buf, base + nibble * 2u);
}

uint palette32_lookup(ByteAddressBuffer buf, uint base, uint voxel_idx, uint palette_len) {
    uint bit_idx = voxel_idx * 5u;
    uint byte_idx = bit_idx >> 3u;
    uint bit_off = bit_idx & 7u;
    uint b0 = read_u8(buf, base + 64u + byte_idx);
    uint b1 = (byte_idx + 1u < 320u) ? read_u8(buf, base + 64u + byte_idx + 1u) : 0u;
    uint raw = b0 | (b1 << 8u);
    uint idx = (raw >> bit_off) & 0x1Fu;
    if (idx >= palette_len) {
        idx = 0u;
    }
    return read_u16(buf, base + idx * 2u);
}

uint raw16_lookup(ByteAddressBuffer buf, uint base, uint voxel_idx) {
    return read_u16(buf, base + voxel_idx * 2u);
}

vec3 calculate_normal(vec3 hit_point, vec3 box_min, vec3 box_max) {
    vec3 center = (box_min + box_max) * 0.5;
    vec3 half_size = (box_max - box_min) * 0.5;
    vec3 rel = hit_point - center;
    vec3 abs_rel = abs(rel) / half_size;

    if (abs_rel.x > abs_rel.y && abs_rel.x > abs_rel.z) {
        return vec3(sign(rel.x), 0.0, 0.0);
    } else if (abs_rel.y > abs_rel.z) {
        return vec3(0.0, sign(rel.y), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(rel.z));
    }
}

struct RayHit {
    bool hit;
    uint block_id;
    vec3 position;
    vec3 normal;
    float t;
    uint traversal_steps;
    uint lod;
};

struct Interval {
    float t_near;
    float t_far;
    uint lod;
};

int wrap_index(int v, int size) {
    int r = v % size;
    return r < 0 ? r + size : r;
}

uint wrapped_page_index(ivec3 page) {
    int px = wrap_index(page.x, int(PAGE_GRID));
    int py = wrap_index(page.y, int(PAGE_GRID));
    int pz = wrap_index(page.z, int(PAGE_GRID));
    return uint(px + py * int(PAGE_GRID) + pz * int(PAGE_GRID * PAGE_GRID));
}

float min3(vec3 v) {
    return min(min(v.x, v.y), v.z);
}

bvec3 dda_step_axes(vec3 t_max) {
    return bvec3(
        t_max.x <= t_max.y && t_max.x <= t_max.z,
        t_max.y <= t_max.x && t_max.y <= t_max.z,
        t_max.z <= t_max.x && t_max.z <= t_max.y
    );
}

void advance_dda(
    inout float t,
    float t_next,
    inout ivec3 cell,
    ivec3 step,
    inout vec3 t_max,
    vec3 t_delta,
    bvec3 axes
) {
    t = t_next;
    if (axes.x) {
        t_max.x += t_delta.x;
        cell.x += step.x;
    }
    if (axes.y) {
        t_max.y += t_delta.y;
        cell.y += step.y;
    }
    if (axes.z) {
        t_max.z += t_delta.z;
        cell.z += step.z;
    }
}

bool is_page_missing_at_position(ClipmapInfoBuffer clipmap, uint lod, vec3 world_pos) {
    if (lod >= LOD_COUNT || clipmap.voxel_size[lod].x == 0u) {
        return true;
    }

    float page_size = float(clipmap.voxel_size[lod].x) * float(PAGE_VOXELS_AXIS);
    ivec3 page = ivec3(floor(world_pos / page_size));
    uint page_index = wrapped_page_index(page);

    PageCoordBuffer page_coords = PageCoordBuffer(clipmap.page_coord_addr[lod]);
    ivec3 slot_coord = page_coords.data[page_index].xyz;
    return !all(equal(slot_coord, page));
}

RayHit trace_brick(
    vec3 ray_origin,
    vec3 ray_dir,
    float t_start,
    float t_end,
    vec3 brick_min,
    float voxel_size,
    uint brick_id,
    uint max_steps,
    inout uint steps,
    ByteAddressBuffer header_buf,
    ByteAddressBuffer pal16_buf,
    ByteAddressBuffer pal32_buf,
    ByteAddressBuffer raw_buf
) {
    RayHit hit;
    hit.hit = false;
    hit.block_id = 0u;
    hit.t = t_end;
    hit.position = vec3(0.0);
    hit.normal = vec3(0.0);
    hit.traversal_steps = 0u;
    hit.lod = 0u;

    uint header_base = brick_id * 32u;
    uint palette_len = read_u8(header_buf, header_base + 0u);
    uint encoding = read_u8(header_buf, header_base + 1u);
    uint data_index = read_u32(header_buf, header_base + 4u);
    uint occ_l0_lo = read_u32(header_buf, header_base + 8u);
    uint occ_l0_hi = read_u32(header_buf, header_base + 12u);
    if ((occ_l0_lo | occ_l0_hi) == 0u) {
        return hit;
    }

    float local_eps = max(DDA_EPS * 0.25, voxel_size * 1e-5);
    float interval_len = max(t_end - t_start, 0.0);
    // Keep the start nudge smaller than the traversed segment to avoid skipping
    // thin edge voxels at brick boundaries.
    float start_nudge = min(local_eps, interval_len * 0.25);
    float t = t_start + start_nudge;
    vec3 inv_dir = 1.0 / ray_dir;
    vec3 pos = ray_origin + ray_dir * t;

    vec3 local = (pos - brick_min) / voxel_size;
    ivec3 voxel = ivec3(floor(local));
    voxel = clamp(voxel, ivec3(0), ivec3(int(BRICK_SIZE) - 1));

    ivec3 step = ivec3(sign(ray_dir));
    vec3 voxel_min = brick_min + vec3(voxel) * voxel_size;
    vec3 next_boundary = mix(voxel_min, voxel_min + vec3(voxel_size), greaterThan(step, ivec3(0)));

    vec3 t_max = vec3(t) + (next_boundary - pos) * inv_dir;
    vec3 t_delta = abs(vec3(voxel_size) * inv_dir);

    while (t <= t_end && steps < max_steps) {
        steps++;

        uint voxel_idx = uint(voxel.x + voxel.y * int(BRICK_SIZE) + voxel.z * int(BRICK_SIZE * BRICK_SIZE));
        uint block_id = 0u;
        if (encoding == 0u) {
            block_id = palette16_lookup(pal16_buf, data_index * STRIDE_PALETTE16, voxel_idx);
        } else if (encoding == 1u) {
            block_id = palette32_lookup(pal32_buf, data_index * STRIDE_PALETTE32, voxel_idx, palette_len);
        } else {
            block_id = raw16_lookup(raw_buf, data_index * STRIDE_RAW16, voxel_idx);
        }

        if (block_id != 0u) {
            float hit_t = max(t, 0.001);
            vec3 hit_pos = ray_origin + ray_dir * hit_t;
            vec3 vmin = brick_min + vec3(voxel) * voxel_size;
            vec3 vmax = vmin + vec3(voxel_size);

            hit.hit = true;
            hit.block_id = block_id;
            hit.t = hit_t;
            hit.position = hit_pos;
            hit.normal = calculate_normal(hit_pos, vmin, vmax);
            hit.traversal_steps = steps;
            return hit;
        }

        float t_next = min3(t_max);
        if (t_next >= t_end) {
            break;
        }

        // Advance to next voxel
        bvec3 axes = dda_step_axes(t_max);
        advance_dda(t, t_next, voxel, step, t_max, t_delta, axes);
        if (voxel.x < 0 || voxel.x >= int(BRICK_SIZE) ||
            voxel.y < 0 || voxel.y >= int(BRICK_SIZE) ||
            voxel.z < 0 || voxel.z >= int(BRICK_SIZE)) {
            break;
        }
    }

    return hit;
}

RayHit trace_interval(
    vec3 ray_origin,
    vec3 ray_dir,
    float t_start,
    float t_end,
    uint lod,
    ClipmapInfoBuffer clipmap,
    out bool had_missing_pages,
    out bool step_budget_exhausted
) {
    RayHit miss;
    miss.hit = false;
    miss.block_id = 0u;
    miss.t = t_end;
    miss.position = vec3(0.0);
    miss.normal = vec3(0.0);
    miss.traversal_steps = 0u;
    miss.lod = lod;
    had_missing_pages = false;
    step_budget_exhausted = false;

    vec3 inv_dir = 1.0 / ray_dir;
    float voxel_size = float(clipmap.voxel_size[lod].x);
    float page_size = voxel_size * float(PAGE_VOXELS_AXIS);
    float brick_size = voxel_size * float(BRICK_SIZE);
    float local_eps = max(DDA_EPS * 0.25, voxel_size * 1e-5);
    float interval_len = max(t_end - t_start, 0.0);
    float start_nudge = min(local_eps, interval_len * 0.25);

    float t = t_start + start_nudge;
    vec3 start_pos = ray_origin + ray_dir * t;
    ivec3 page = ivec3(floor(start_pos / page_size));
    ivec3 step = ivec3(sign(ray_dir));

    vec3 page_min = vec3(page) * page_size;
    vec3 next_boundary = mix(page_min, page_min + vec3(page_size), greaterThan(step, ivec3(0)));
    vec3 t_max = vec3(t) + (next_boundary - start_pos) * inv_dir;
    vec3 t_delta = abs(vec3(page_size) * inv_dir);
    uint steps = 0u;

    PageBrickBuffer page_bricks = PageBrickBuffer(clipmap.page_brick_indices_addr[lod]);
    PageOccBuffer page_occ = PageOccBuffer(clipmap.page_occ_addr[lod]);
    PageCoordBuffer page_coords = PageCoordBuffer(clipmap.page_coord_addr[lod]);
    ByteAddressBuffer header_buf = ByteAddressBuffer(clipmap.brick_header_addr);
    ByteAddressBuffer pal16_buf = ByteAddressBuffer(clipmap.palette16_addr);
    ByteAddressBuffer pal32_buf = ByteAddressBuffer(clipmap.palette32_addr);
    ByteAddressBuffer raw_buf = ByteAddressBuffer(clipmap.raw16_addr);

    while (t <= t_end && steps < pc.max_steps) {
        uint page_index = wrapped_page_index(page);

        float t_next = min3(t_max);
        float t_page_end = min(t_next, t_end);

        ivec3 slot_coord = page_coords.data[page_index].xyz;
        bool slot_matches = all(equal(slot_coord, page));
        if (!slot_matches) {
            had_missing_pages = true;
        }
        if (slot_matches) {
            uvec2 occ = page_occ.data[page_index];
            if ((occ.x | occ.y) != 0u) {
                vec3 page_origin = vec3(page) * page_size;
                float brick_interval_len = max(t_page_end - t, 0.0);
                float brick_start_nudge = min(local_eps, brick_interval_len * 0.25);
                vec3 page_start = ray_origin + ray_dir * (t + brick_start_nudge);
                ivec3 brick = ivec3(floor((page_start - page_origin) / brick_size));
                brick = clamp(brick, ivec3(0), ivec3(int(PAGE_BRICKS_AXIS) - 1));

                ivec3 brick_step = ivec3(sign(ray_dir));
                vec3 brick_min = page_origin + vec3(brick) * brick_size;
                vec3 brick_boundary = mix(brick_min, brick_min + vec3(brick_size), greaterThan(brick_step, ivec3(0)));
                vec3 brick_t_max = vec3(t) + (brick_boundary - page_start) * inv_dir;
                vec3 brick_t_delta = abs(vec3(brick_size) * inv_dir);

                float tb = t;
                while (tb <= t_page_end && steps < pc.max_steps) {
                    uint brick_idx = uint(brick.x + brick.y * int(PAGE_BRICKS_AXIS) + brick.z * int(PAGE_BRICKS_AXIS * PAGE_BRICKS_AXIS));
                    uint brick_id = page_bricks.data[page_index * PAGE_BRICKS + brick_idx];

                    float tb_next = min3(brick_t_max);
                    float tb_end = min(tb_next, t_page_end);

                    if (brick_id != 0u) {
                        RayHit brick_hit = trace_brick(
                            ray_origin,
                            ray_dir,
                            tb,
                            tb_end,
                            page_origin + vec3(brick) * brick_size,
                            voxel_size,
                            brick_id,
                            pc.max_steps,
                            steps,
                            header_buf,
                            pal16_buf,
                            pal32_buf,
                            raw_buf
                        );

                        if (brick_hit.hit) {
                            brick_hit.lod = lod;
                            brick_hit.traversal_steps = steps;
                            return brick_hit;
                        }
                    }

                    if (tb_next >= t_page_end) {
                        break;
                    }

                    bvec3 brick_axes = dda_step_axes(brick_t_max);
                    advance_dda(tb, tb_next, brick, brick_step, brick_t_max, brick_t_delta, brick_axes);
                    if (brick.x < 0 || brick.x >= int(PAGE_BRICKS_AXIS) ||
                        brick.y < 0 || brick.y >= int(PAGE_BRICKS_AXIS) ||
                        brick.z < 0 || brick.z >= int(PAGE_BRICKS_AXIS)) {
                        break;
                    }
                }
            }
        }

        if (t_next >= t_end) {
            break;
        }

        bvec3 page_axes = dda_step_axes(t_max);
        advance_dda(t, t_next, page, step, t_max, t_delta, page_axes);

        steps++;
    }

    if (steps >= pc.max_steps && t < t_end) {
        step_budget_exhausted = true;
    }
    miss.traversal_steps = steps;
    return miss;
}

RayHit trace_clipmap(vec3 ray_origin, vec3 ray_dir) {
    RayHit closest;
    closest.hit = false;
    closest.block_id = 0u;
    closest.t = 1e30;
    closest.position = vec3(0.0);
    closest.normal = vec3(0.0);
    closest.traversal_steps = 0u;
    closest.lod = 0u;

    ClipmapInfoBuffer clipmap = ClipmapInfoBuffer(pc.clipmap_info_address);
    vec3 inv_dir = 1.0 / ray_dir;

    Interval intervals[12];
    int interval_count = 0;

    for (uint lod = 0u; lod < LOD_COUNT; lod++) {
        if (clipmap.voxel_size[lod].x == 0u) {
            continue;
        }
        vec3 box_min = clipmap.lod_aabb_min[lod].xyz;
        vec3 box_max = clipmap.lod_aabb_max[lod].xyz;

        float t_near;
        float t_far;
        if (!ray_aabb_intersect(ray_origin, inv_dir, box_min, box_max, t_near, t_far)) {
            continue;
        }

        if (lod == 0u) {
            intervals[interval_count++] = Interval(t_near, t_far, lod);
        } else {
            vec3 inner_min_full = clipmap.lod_aabb_min[lod - 1u].xyz;
            vec3 inner_max_full = clipmap.lod_aabb_max[lod - 1u].xyz;
            float transition_band = float(PAGE_VOXELS_AXIS) * float(clipmap.voxel_size[lod - 1u].x);
            vec3 inner_min = inner_min_full + vec3(transition_band);
            vec3 inner_max = inner_max_full - vec3(transition_band);
            if (any(greaterThanEqual(inner_min, inner_max))) {
                inner_min = inner_min_full;
                inner_max = inner_max_full;
            }

            float t_in_near;
            float t_in_far;
            bool inner_hit = ray_aabb_intersect(ray_origin, inv_dir, inner_min, inner_max, t_in_near, t_in_far);
            // Keep shell trimming small enough to avoid visible seam gaps at LOD boundaries.
            float shell_eps = max(DDA_EPS, float(clipmap.voxel_size[lod].x) * 0.002);

            if (!inner_hit) {
                intervals[interval_count++] = Interval(t_near, t_far, lod);
            } else {
                if (t_in_near - shell_eps > t_near) {
                    intervals[interval_count++] = Interval(t_near, t_in_near - shell_eps, lod);
                }
                if (t_in_far + shell_eps < t_far) {
                    intervals[interval_count++] = Interval(t_in_far + shell_eps, t_far, lod);
                }
            }
        }
    }

    // Sort intervals front-to-back (simple bubble for <=12)
    for (int i = 0; i < interval_count - 1; i++) {
        for (int j = 0; j < interval_count - i - 1; j++) {
            if (intervals[j].t_near > intervals[j + 1].t_near) {
                Interval tmp = intervals[j];
                intervals[j] = intervals[j + 1];
                intervals[j + 1] = tmp;
            }
        }
    }

    uint total_steps = 0u;

    for (int i = 0; i < interval_count; i++) {
        Interval interval = intervals[i];
        float t_start = max(interval.t_near, 0.0);
        float t_end = interval.t_far;
        if (t_start >= t_end) {
            continue;
        }

        bool missing_pages = false;
        bool step_budget_exhausted = false;
        RayHit hit = trace_interval(
            ray_origin,
            ray_dir,
            t_start,
            t_end,
            interval.lod,
            clipmap,
            missing_pages,
            step_budget_exhausted
        );
        total_steps += hit.traversal_steps;

        if (!hit.hit && (missing_pages || step_budget_exhausted)) {
            bool allow_approx_fallback = step_budget_exhausted;
            for (uint fallback_lod = interval.lod + 1u; fallback_lod < LOD_COUNT; fallback_lod++) {
                if (clipmap.voxel_size[fallback_lod].x == 0u) {
                    continue;
                }

                bool fallback_missing = false;
                bool fallback_budget_exhausted = false;
                RayHit fallback_hit = trace_interval(
                    ray_origin,
                    ray_dir,
                    t_start,
                    t_end,
                    fallback_lod,
                    clipmap,
                    fallback_missing,
                    fallback_budget_exhausted
                );
                total_steps += fallback_hit.traversal_steps;

                if (fallback_hit.hit) {
                    if (!allow_approx_fallback) {
                        // Only allow fallback if the fine LOD page at the hit position is genuinely missing.
                        // This prevents coarse voxels from leaking over valid fine data.
                        float fine_voxel = max(float(clipmap.voxel_size[interval.lod].x), 1.0);
                        vec3 probe_pos = fallback_hit.position - ray_dir * (fine_voxel * 0.25);
                        if (!is_page_missing_at_position(clipmap, interval.lod, probe_pos)) {
                            continue;
                        }
                    }
                    hit = fallback_hit;
                    break;
                }

                if (!fallback_missing && !fallback_budget_exhausted) {
                    break;
                }
            }
        }

        if (hit.hit && hit.t < closest.t) {
            closest = hit;
            closest.traversal_steps = total_steps;
            break;
        }
    }

    closest.traversal_steps = total_steps;
    return closest;
}

// Debug visualization helpers
vec3 turbo_colormap(float t) {
    t = clamp(t, 0.0, 1.0);
    const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);
    const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);
    const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);
    const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);
    const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);
    const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);

    float t2 = t * t;
    float t3 = t2 * t;
    float t4 = t3 * t;
    float t5 = t4 * t;

    vec3 color;
    color.r = kRedVec4.x + kRedVec4.y * t + kRedVec4.z * t2 + kRedVec4.w * t3 + kRedVec2.x * t4 + kRedVec2.y * t5;
    color.g = kGreenVec4.x + kGreenVec4.y * t + kGreenVec4.z * t2 + kGreenVec4.w * t3 + kGreenVec2.x * t4 + kGreenVec2.y * t5;
    color.b = kBlueVec4.x + kBlueVec4.y * t + kBlueVec4.z * t2 + kBlueVec4.w * t3 + kBlueVec2.x * t4 + kBlueVec2.y * t5;

    return clamp(color, 0.0, 1.0);
}

vec3 debug_normals(vec3 n) {
    return n * 0.5 + 0.5;
}

uint hash_u32(uint x) {
    x ^= x >> 16u;
    x *= 0x7FEB352Du;
    x ^= x >> 15u;
    x *= 0x846CA68Bu;
    x ^= x >> 16u;
    return x;
}

float hash2d(ivec2 p, uint seed) {
    uint h = uint(p.x) * 0x9E3779B9u;
    h ^= uint(p.y) * 0x85EBCA6Bu;
    h ^= seed * 0xC2B2AE35u;
    return float(hash_u32(h)) * (1.0 / 4294967295.0);
}

float value_noise(vec2 p, uint seed) {
    ivec2 i = ivec2(floor(p));
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);

    float n00 = hash2d(i, seed);
    float n10 = hash2d(i + ivec2(1, 0), seed);
    float n01 = hash2d(i + ivec2(0, 1), seed);
    float n11 = hash2d(i + ivec2(1, 1), seed);

    float nx0 = mix(n00, n10, u.x);
    float nx1 = mix(n01, n11, u.x);
    return mix(nx0, nx1, u.y) * 2.0 - 1.0;
}

float fbm_noise(vec2 p, uint seed) {
    float sum = 0.0;
    float amp = 0.5;
    float freq = 1.0;
    for (int i = 0; i < 4; i++) {
        sum += value_noise(p * freq, seed + uint(i) * 131u) * amp;
        freq *= 2.0;
        amp *= 0.5;
    }
    return sum;
}

struct CelestialLighting {
    vec3 sun_dir;
    vec3 moon_dir;
    float sun_visibility;
    float moon_visibility;
    float daylight;
};

CelestialLighting compute_celestial_lighting() {
    float day_phase = fract(camera.day_night.x);
    float orbit = day_phase * TAU;

    vec3 sun_dir = normalize(vec3(cos(orbit), sin(orbit), 0.35));
    vec3 moon_dir = -sun_dir;

    CelestialLighting lighting;
    lighting.sun_dir = sun_dir;
    lighting.moon_dir = moon_dir;
    lighting.sun_visibility = smoothstep(-0.18, 0.08, sun_dir.y);
    lighting.moon_visibility = smoothstep(-0.18, 0.08, moon_dir.y);
    lighting.daylight = clamp(lighting.sun_visibility, 0.0, 1.0);
    return lighting;
}

vec3 sky_color(vec3 ray_dir, CelestialLighting lighting) {
    float sky_t = clamp(ray_dir.y * 0.5 + 0.5, 0.0, 1.0);

    vec3 day_horizon = vec3(0.74, 0.84, 0.96);
    vec3 day_zenith = vec3(0.20, 0.47, 0.85);
    vec3 night_horizon = vec3(0.03, 0.06, 0.12);
    vec3 night_zenith = vec3(0.005, 0.01, 0.03);

    vec3 day_sky = mix(day_horizon, day_zenith, pow(sky_t, 0.7));
    vec3 night_sky = mix(night_horizon, night_zenith, pow(sky_t, 0.8));
    vec3 sky = mix(night_sky, day_sky, lighting.daylight);

    float twilight = smoothstep(-0.25, 0.05, lighting.sun_dir.y) *
                     (1.0 - smoothstep(0.05, 0.3, lighting.sun_dir.y));
    float horizon = exp(-max(ray_dir.y, 0.0) * 14.0);
    sky += vec3(0.58, 0.28, 0.12) * twilight * horizon * 0.6;

    float sun_alignment = max(dot(ray_dir, lighting.sun_dir), 0.0);
    float sun_glow = pow(sun_alignment, 18.0) * lighting.sun_visibility;
    float sun_disk = pow(sun_alignment, 1100.0) * lighting.sun_visibility;
    sky += vec3(1.0, 0.62, 0.30) * sun_glow * 0.65;
    sky += vec3(1.0, 0.96, 0.88) * sun_disk * 5.0;

    float moon_alignment = max(dot(ray_dir, lighting.moon_dir), 0.0);
    float moon_glow = pow(moon_alignment, 12.0) * lighting.moon_visibility;
    float moon_disk = pow(moon_alignment, 1400.0) * lighting.moon_visibility;
    sky += vec3(0.35, 0.43, 0.58) * moon_glow * 0.45;
    sky += vec3(0.83, 0.88, 1.0) * moon_disk * 1.4;

    return sky;
}

vec3 apply_lighting(vec3 base_color, vec3 normal, CelestialLighting lighting) {
    float sun_ndotl = max(dot(normal, lighting.sun_dir), 0.0);
    float moon_ndotl = max(dot(normal, lighting.moon_dir), 0.0);

    vec3 ambient_night = vec3(0.04, 0.05, 0.08);
    vec3 ambient_day = vec3(0.23, 0.24, 0.26);
    vec3 ambient = mix(ambient_night, ambient_day, lighting.daylight);

    vec3 sun_color = mix(
        vec3(1.0, 0.54, 0.34),
        vec3(1.0, 0.97, 0.92),
        smoothstep(0.0, 0.6, lighting.sun_dir.y)
    );
    vec3 moon_color = vec3(0.46, 0.55, 0.74);

    vec3 direct = sun_color * (sun_ndotl * lighting.sun_visibility * 0.95) +
                  moon_color * (moon_ndotl * lighting.moon_visibility * 0.30);
    return base_color * (ambient + direct);
}

vec3 biome_debug_color(RayHit hit, vec3 ray_dir, CelestialLighting lighting) {
    if (!hit.hit) {
        return sky_color(ray_dir, lighting);
    }

    const float TERRAIN_SCALE = 102.0;
    const float BIOME_SCALE = 2200.0;
    const float TEMPERATURE_SCALE = 2400.0;
    const float MOISTURE_SCALE = 2300.0;
    const float MOUNTAIN_REGION_SCALE = 1900.0;
    const float SEA_LEVEL = 60.0;
    const float SNOW_HINT = SEA_LEVEL + 44.0;

    vec2 world = hit.position.xz;
    vec2 nxz = world / TERRAIN_SCALE;
    vec2 bxz = world / BIOME_SCALE;

    float ridge_base = fbm_noise(nxz * 0.55, 13u);
    float ridge = pow(clamp(1.0 - abs(ridge_base), 0.0, 1.0), 0.85);
    float macro_shape = fbm_noise(bxz * 0.9, 11u);
    float macro01 = (macro_shape + 1.0) * 0.5;
    float relief = clamp(ridge * 0.52 + macro01 * 0.48, 0.0, 1.0);

    float mountain_region = (fbm_noise(world / MOUNTAIN_REGION_SCALE, 17u) + 1.0) * 0.5;
    float mountain_gate = smoothstep(0.52, 0.78, mountain_region);
    float ridge_break = smoothstep(
        0.68,
        0.90,
        abs(fbm_noise(nxz * 0.34 + vec2(7.7, -15.3), 19u))
    );
    float mountain_core = smoothstep(0.70, 0.90, relief);
    float mountain_weight = mountain_core * mountain_gate * clamp(1.0 - ridge_break * 0.30, 0.0, 1.0);
    float hill_weight = smoothstep(0.48, 0.82, relief) * (1.0 - mountain_weight * 0.82);

    float temperature = fbm_noise(world / TEMPERATURE_SCALE, 23u);
    float moisture = fbm_noise(world / MOISTURE_SCALE, 29u);
    float desert_region = fbm_noise(bxz * 0.65 + vec2(7.1, -9.3), 31u);
    bool cold = temperature < -0.12;
    bool wet = moisture > 0.22;
    bool high_elevation = hit.position.y >= (SNOW_HINT - 10.0);
    float heat = smoothstep(0.00, 0.45, temperature);
    float aridity = smoothstep(-0.08, 0.45, temperature - moisture * 0.95);
    float desert_zone = smoothstep(0.08, 0.55, desert_region);
    float desert_strength = clamp(heat * 0.40 + aridity * 0.40 + desert_zone * 0.20, 0.0, 1.0);

    vec3 biome_color;
    if (mountain_weight > 0.54 && cold && high_elevation) {
        biome_color = vec3(0.78, 0.88, 0.99); // SnowyMountains
    } else if (desert_strength > 0.58 && mountain_weight < 0.58) {
        biome_color = vec3(0.93, 0.82, 0.43); // Desert
    } else if (mountain_weight > 0.52 || hill_weight > 0.62) {
        biome_color = vec3(0.70, 0.48, 0.30); // Hills
    } else if (wet) {
        biome_color = vec3(0.14, 0.50, 0.20); // Forest
    } else {
        biome_color = vec3(0.44, 0.70, 0.28); // Plains
    }

    // Keep water/snow/sand visibly distinct in biome mode.
    if (hit.block_id == 6u) {
        biome_color = mix(biome_color, vec3(0.16, 0.40, 0.85), 0.78);
    } else if (hit.block_id == 4u) {
        biome_color = mix(biome_color, vec3(0.92, 0.95, 1.0), 0.72);
    } else if (hit.block_id == 5u) {
        biome_color = mix(biome_color, vec3(0.92, 0.82, 0.48), 0.70);
    }

    return apply_lighting(biome_color, hit.normal, lighting);
}

bool is_on_lod_boundary(vec3 world_pos, ClipmapInfoBuffer clipmap, float threshold) {
    for (uint i = 0u; i < LOD_COUNT; i++) {
        vec3 minb = clipmap.lod_aabb_min[i].xyz;
        vec3 maxb = clipmap.lod_aabb_max[i].xyz;
        if (world_pos.x - minb.x < threshold || maxb.x - world_pos.x < threshold ||
            world_pos.y - minb.y < threshold || maxb.y - world_pos.y < threshold ||
            world_pos.z - minb.z < threshold || maxb.z - world_pos.z < threshold) {
            return true;
        }
    }
    return false;
}

vec3 get_block_color(uint block_id) {
    switch (block_id) {
        case 1u: return vec3(0.5, 0.5, 0.5);
        case 2u: return vec3(0.54, 0.35, 0.17);
        case 3u: return vec3(0.34, 0.49, 0.27);
        case 4u: return vec3(0.94, 0.95, 0.98);
        case 5u: return vec3(0.84, 0.78, 0.52);
        case 6u: return vec3(0.22, 0.45, 0.77);
        case 7u: return vec3(0.38, 0.27, 0.16);
        case 8u: return vec3(0.24, 0.46, 0.20);
        case 9u: return vec3(0.88, 0.28, 0.33);
        default: return vec3(0.8, 0.2, 0.8);
    }
}

vec3 shade(RayHit hit, vec3 ray_dir, CelestialLighting lighting) {
    if (!hit.hit) {
        return sky_color(ray_dir, lighting);
    }

    vec3 base_color = get_block_color(hit.block_id);
    return apply_lighting(base_color, hit.normal, lighting);
}

void main() {
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= pc.screen_size.x || pixel.y >= pc.screen_size.y) {
        return;
    }

    vec2 uv = (vec2(pixel) + 0.5) / vec2(pc.screen_size);
    vec2 ndc = uv * 2.0 - 1.0;

    vec4 clip = vec4(ndc.x, -ndc.y, 1.0, 1.0);
    vec4 view_pos = camera.inverse_projection * clip;
    view_pos = vec4(view_pos.xyz / view_pos.w, 0.0);

    vec3 ray_origin = camera.position.xyz;
    vec3 ray_dir = normalize((camera.inverse_view * view_pos).xyz);

    RayHit hit = trace_clipmap(ray_origin, ray_dir);
    CelestialLighting lighting = compute_celestial_lighting();

    vec3 color;
    switch (pc.debug_mode) {
        case DEBUG_TRAVERSAL_STEPS: {
            float step_ratio = float(hit.traversal_steps) / float(pc.max_steps);
            color = turbo_colormap(step_ratio);
            break;
        }
        case DEBUG_NODE_DEPTH: {
            if (hit.hit) {
                float lod_ratio = float(hit.lod) / float(LOD_COUNT - 1u);
                color = turbo_colormap(lod_ratio);
            } else {
                color = vec3(0.0);
            }
            break;
        }
        case DEBUG_DISTANCE: {
            float dist_ratio = hit.t / 500.0;
            color = turbo_colormap(clamp(dist_ratio, 0.0, 1.0));
            if (!hit.hit) {
                color = vec3(0.1, 0.1, 0.2);
            }
            break;
        }
        case DEBUG_NORMALS: {
            if (hit.hit) {
                color = debug_normals(hit.normal);
            } else {
                color = sky_color(ray_dir, lighting);
            }
            break;
        }
        case DEBUG_BIOMES: {
            color = biome_debug_color(hit, ray_dir, lighting);
            break;
        }
        case DEBUG_CHUNK_BOUNDARIES: {
            ClipmapInfoBuffer clipmap = ClipmapInfoBuffer(pc.clipmap_info_address);
            color = shade(hit, ray_dir, lighting);
            if (hit.hit && is_on_lod_boundary(hit.position, clipmap, 0.15)) {
                color = mix(color, vec3(1.0, 0.2, 0.2), 0.7);
            }
            break;
        }
        case DEBUG_NONE:
        default:
            color = shade(hit, ray_dir, lighting);
            break;
    }

    imageStore(output_image, ivec2(pixel), vec4(color, 1.0));
}
